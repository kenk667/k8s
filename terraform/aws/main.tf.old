provider "aws" {
  region  = "us-gov-west-1"
  profile = "some_profile"
}

#It's important to have the correct terraform versiosn, all versions at https://releases.hashicorp.com/terraform/
terraform {
  required_version = ">= 0.12"  
  backend "s3" {
    bucket  = "antipode"
    key     = "terraform/aws/v12/terrafrom.tfstate"
    region  = "us-gov-west-1"
    profile = "some_profile"
  }
}

#This data source fetches the current available zones based on the region set in the provider
data "aws_availability_zones" "available_zones" {
}

# #This module calls the voc-network module to establish new VPC and asscociated IPs
# module "management_vpc" {
#   source = "../modules/vpc-network"

#   prefix                = "mad-hatter2"
#   vpc_cidr              = "10.0.0.0/16"
#   public_subnet_a_cidr  = "10.0.0.0/24"
#   public_subnet_b_cidr  = "10.0.1.0/24"
#   public_subnet_c_cidr  = "10.0.2.0/24"
#   private_subnet_a_cidr = "10.0.3.0/24"
#   private_subnet_b_cidr = "10.0.4.0/24"
#   private_subnet_c_cidr = "10.0.5.0/24"

# }

#This data source gets a list of VPCs based on the user-inputted VPC name 
data "aws_vpcs" "vpc_list" {
  filter {
    name   = "tag-value"
    values = [var.vpc_name]
  }
}

#This block selects the first VPC from the list of vpcs generated in "vpc_list"
//Just fixed below to v12 syntax, the list had to be flatten first and then pick which out of that list outside of that backet
data "aws_vpc" "vpc0" {
  id = flatten([data.aws_vpcs.vpc_list.ids])[0]
}

# The modules below create an individual module for each subnet that we want
# to initialize. Each module contains 3 subnets, one for each available zone

module "private_subnet" {
  source            = "../modules/subnets"
  input_cidr_block  = data.aws_vpc.vpc0.cidr_block
  third_octet_start = var.private_octet
  vpc_id            = data.aws_vpc.vpc0.id
  tag               = "private_subnet"
}

module "public_subnet" {
  source            = "../modules/subnets"
  input_cidr_block  = data.aws_vpc.vpc0.cidr_block
  third_octet_start = var.public_octet
  vpc_id            = data.aws_vpc.vpc0.id
  tag               = "public_subnet"
}

module "services_subnet" {
  source            = "../modules/subnets"
  input_cidr_block  = data.aws_vpc.vpc0.cidr_block
  third_octet_start = var.services_octet
  vpc_id            = data.aws_vpc.vpc0.id
  tag               = "services_subnet"
}

module "dynamic_subnet" {
  source            = "../modules/subnets"
  input_cidr_block  = data.aws_vpc.vpc0.cidr_block
  third_octet_start = var.dynamic_octet
  vpc_id            = data.aws_vpc.vpc0.id
  tag               = "dynamic_subnet"
}

module "rds_subnet" {
  source            = "../modules/subnets"
  input_cidr_block  = data.aws_vpc.vpc0.cidr_block
  third_octet_start = var.rds_octet
  vpc_id            = data.aws_vpc.vpc0.id
  tag               = "rds_subnet"
}

resource "aws_subnet" "k8s-kontrol" {
  vpc_id            = data.aws_vpc.vpc0.id
  availability_zone = data.aws_availability_zones.available_zones.names[0]
  cidr_block        = "${local.subnet_list[0]}/24"
  tags              = { Name = "k8s-kontrol" }
}

#gets the IGW ID if one exist
# data "aws_internet_gateway" "gw" {
#   filter {
#     name   = "attachment.vpc-id"
#     values = [data.aws_vpc.vpc0.id]
#   }
#   tags = { Name = "mad-hatter" }
# }

#interpolates output from perviouos block and determines if there is a IGW ID or not. If there is it ignores, if there isn't it'll create a new one
# //Note: It's recommended to denote that the AWS Instance or Elastic IP depends on this Internet Gateway.
resource "aws_internet_gateway" "vpc_igw" {
  vpc_id = data.aws_vpc.vpc0.id
  # count = (data.aws_internet_gateway.gw.id == "" ? 1 : 0)
  tags = { Name = "mad-hatter" }
}


# create a route_table and associate it with our vpc
resource "aws_route_table" "public_rtable" {
  count  = 3
  vpc_id = data.aws_vpc.vpc0.id
  # associate all IPs with this route table
  # TODO in theory this should route everything inside of the public subnet to the route gw
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.vpc_igw.id
  }
  tags = { 
    Name = "mad-hatter" 
    }
}

# associate the 3 public subnets with their corresponding route table
resource "aws_route_table_association" "public_association" {
  count          = 3
  subnet_id      = local.public_subnet_ids_list[count.index]
  route_table_id = element(aws_route_table.public_rtable.*.id, count.index)
  //TODO set tags properly for each subnet
}

resource "aws_network_acl" "main" {
  vpc_id = data.aws_vpc.vpc0.id
  subnet_ids = local.public_subnet_ids_list

  egress {
    protocol   = "tcp"
    rule_no    = 200
    action     = "allow"
    cidr_block = "10.3.0.0/18"
    from_port  = 443
    to_port    = 443
  }

  ingress {
    protocol   = "tcp"
    rule_no    = 100
    action     = "allow"
    cidr_block = "10.3.0.0/18"
    from_port  = 80
    to_port    = 80
  }

  tags = {
    Name = "mad-hatter"
  }
}

#TODO do we need 3 of these?
resource "aws_elb" "lb" {
  subnets = [
    module.public_subnet.subnet_1a_id,
    module.public_subnet.subnet_1b_id,
    module.public_subnet.subnet_1c_id,
  ]

  # TODO unable to get correct access here
  # access_logs {
  #   bucket        = "antipode"
  #   bucket_prefix = "terraform/logs"
  #   interval      = 60
  # }

  listener {
    instance_port     = 8000
    instance_protocol = "http"
    lb_port           = 80
    lb_protocol       = "http"
  }

  # TODO need to get an ssl_certificate
  # listener {
  #   instance_port      = 8000
  #   instance_protocol  = "http"
  #   lb_port            = 443
  #   lb_protocol        = "https"
  #   ssl_certificate_id = "arn:aws:iam::123456789012:server-certificate/certName" #TODO ??
  # }

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 3
    target              = "HTTP:8000/"
    interval            = 30
  }

  cross_zone_load_balancing   = true
  idle_timeout                = 400
  connection_draining         = true
  connection_draining_timeout = 400
  tags = { Name = "mad-hatter" }
}

#TODO change these to use count once we figure out what to do with the pools
#TODO what's up with these ip-pools?
resource "aws_eip" "eip_nat_1a" {
  vpc = true
  # public_ipv4_pool = "ipv4pool-ec2-012345"
  tags = { Name = "mad-hatter" }
}

resource "aws_eip" "eip_nat_1b" {
  vpc = true
  # public_ipv4_pool = "ipv4pool-ec2-012345"
  tags = { Name = "mad-hatter" }
}

resource "aws_eip" "eip_nat_1c" {
  vpc = true
  # public_ipv4_pool = "ipv4pool-ec2-012345"
  tags = { Name = "mad-hatter" }
}

# Create 3 nat_gateways, one for each private subnet, each associated with a unique aws_eid
resource "aws_nat_gateway" "private_nat_gw" {
  count         = 3
  allocation_id = local.eip_nat_list[count.index]
  subnet_id     = local.private_subnet_ids_list[count.index]
  tags = { Name = "mad-hatter" }
}

#TODO do I need to route the private subnets to the nat_gateway explicitly?
#TODO do I need one route table for every subnet?
# create a route_table and associate it with our vpc
resource "aws_route_table" "private_rtable" {
  vpc_id = data.aws_vpc.vpc0.id
  count  = 3
  # associate all IPs with this route table
  # TODO in theory this should route everything inside of the private subnet to the route nat_gateway
  route {
    cidr_block = "0.0.0.0/0" //TODO this needs to change?
    nat_gateway_id = element(aws_nat_gateway.private_nat_gw.*.id, count.index)
  }
  tags = { Name = "mad-hatter" }
}

# associate the 3 private subnets with their corresponding route table 
resource "aws_route_table_association" "private_association" {
  count          = 3
  subnet_id      = local.private_subnet_ids_list[count.index]
  route_table_id = element(aws_route_table.private_rtable.*.id, count.index)
}


resource "aws_instance" "web" {
  ami           = "ami-b44b2fd5"
  instance_type = "t2.micro"
  subnet_id = local.public_subnet_ids_list[0]  
  associate_public_ip_address = true
  key_name = "antipodes-mad-hatter"

  tags = {
    Name = "mad-hatter"
  }
  depends_on = [ aws_internet_gateway.vpc_igw ]
}
